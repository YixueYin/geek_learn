***WEEK 4 总结***

**广度优先搜索 深度优先搜索**

1. 遍历搜索

   在树（图/状态集）中寻找特定节点

   保证：每个节点**访问且仅访问一次**

   访问顺序：分为**深度优先和广度优先**（另外就是优先级搜索，这种一般叫做启发式搜索，用于企业级，深度学习等等，比如推荐算法）

2. 深度优先模板（递归/手动维护一个栈）

   void dfs(TreeNode root) {
       if (root == null) {
           return;
       }
       dfs(root.left);
       dfs(root.right);
   }

3. 广度优先模板（维护一个队列）

   扩散方式：就如同一个水滴滴在root上，一层一层扩散出去

   void bfs(TreeNode root) {
       Queue<TreeNode> queue = new ArrayDeque<>();
       queue.add(root);
       while (!queue.isEmpty()) {
           TreeNode node = queue.poll(); // Java 的 pop 写作 poll()
           if (node.left != null) {
               queue.add(node.left);
           }
           if (node.right != null) {
               queue.add(node.right);
           }
       }
   }

   

   

   **如果要记录每一层的信息，按层打出。改造成层序遍历**

   // 二叉树的层序遍历
   void bfs(TreeNode root) {
       Queue<TreeNode> queue = new ArrayDeque<>();
       queue.add(root);
       while (!queue.isEmpty()) {
           int n = queue.size();
           for (int i = 0; i < n; i++) { 
               // 变量 i 无实际意义，只是为了循环 n 次
               TreeNode node = queue.poll();
               if (node.left != null) {
                   queue.add(node.left);
               }
               if (node.right != null) {
                   queue.add(node.right);
               }
           }
       }
   }

   

   

   //参考

   public List<List<Integer>> levelOrder(TreeNode root) {
       List<List<Integer>> res = new ArrayList<>();

       Queue<TreeNode> queue = new ArrayDeque<>();
       if (root != null) {
           queue.add(root);
       }
       while (!queue.isEmpty()) {
           int n = queue.size();
           List<Integer> level = new ArrayList<>();
           for (int i = 0; i < n; i++) { 
               TreeNode node = queue.poll();
               level.add(node.val);
               if (node.left != null) {
                   queue.add(node.left);
               }
               if (node.right != null) {
                   queue.add(node.right);
               }
           }
           res.add(level);
       }
       
       return res;

   }

   

   **贪心算法 Greedy**

   1. 是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法

   2. 贪心算法与动态规划

      不同：贪心在于它对每一个子问题解决方案都做出选择，不能回退

      ​			回溯：能够回退

      ​			动态规划：最优判断+回退（保存之前的运算结果）

   3. 解决问题

      可以用来解决一些最优化问题：图中的最小生成树，哈夫曼编码

      但是在工程或者生活中的问题，贪心法一般不适合

   4. 例题：coin change

      适用贪心算法：只在coin面值可以整除

   5. **难点**

      要证明贪心可以得到最优解

      情况比较特殊：从前往后或者从后往前

   

   **二分查找**

   1. 前提：

      目标函数单调性（单调递增或者递减）

      存在上下界（bounded）

      可以通过索引访问

   2. 代码模板：

      起笔难

      

      

      

      

   