*动态规划题目特点*

**1.计数** +++

有多少种方式走到右下角

有多少种方法选出k个数使得和是Sum

**2.求最大最小值**MAX MIN

从左上角走到右下角路径的最大数字和

最长上升子序列长度

**3. 求存在性** AND OR

取石子游戏，先手是否必胜

能不能选出k个数使得和是Sum



Leetcode：Coin Change

**1.确定状态：**

简单说，解动态规划的时候需要开一个数组，数组的每个元素代表什么。

**需要两个意识**：最后一步&子问题

**最后一步**：虽然不知道最优策略是什么，但是最优策略肯定是k枚硬币加一起是27

所以一定有一枚最后的硬币：ak

除掉这枚硬币，前面的硬币面值加起来是27-ak

***不关心前面的k-1硬币是怎么拼出27-ak***

***因为是最优策略，所以拼出27-ak的硬币数一定要最少，否则就不是最优策略了***



**子问题**

所以我们就要求：最少用多少硬币可以拼出27-ak

所以转化成了一个子问题，规模更小：27-ak

简化定义，我们设状态f(X)=最少用多少枚硬币拼出X

f(27) = min{f(27-2)+1, f(27-5)+1, f(27-7)+1}

**2.转移方程**

f[X] = min{f[X-2]+1, f[X-5]+1, f[X-7]+1}

**3.初始条件**

f[0] = 0

**4.边界情况**

两个问题：X-2，X-5，X-7小于0？什么时候停下来？

解答：如果不能拼出Y，则定义f[Y]=正无穷

**5.计算顺序**

原则，当我们计算到f[X]时，f[X-2]等等都已经得到结果了

**算法时间复杂度**：O（3*27）。也就是O（m*n）

因为每一次尝试3枚硬币，一共尝试27次

**6.附代码**

`class Solution {

  public int change(int amount, int[] coins) {

​    int[] f = new int[amount+1];



​    //initilazation

​    int n = coins.length;

​    int i,j;

​    f[0] = 0;

​    for(i=1;i<=amount;i++){

​      f[i] = Integer.MAX_VALUE;

​      //last coin coins[]

​      //f[i] = min{f[i-coins[0]+1,f[i-coins[1]+1],....f[i-coins[n-1]+1]}

​      for(j=0;j<n;j++){

​        if(i >= coins[j] && f[i-coins[j]]!=Integer.MAX_VALUE){

​          f[i] = Math.min(f[i-coins[j]]+1,f[i]);

​        }

​      }

​    }

​    if(f[amount] == Integer.MAX_VALUE){

​      f[amount] = -1;

​    }

​    return f[amount];

  }

}`

**此处尤其要注意，排列与组合的关系：**

因为爬梯子问题要考虑排列，也就是1-2-3和3-1-2不是一种，所以循环调用的时候把amount放在外面

但是当我们做coins总量的组合问题时，要规定一种面额的硬币只能按顺序出现，也就是说我们要把coins[]数组放在外面便利，否则就会出现得到的数过大的情况（也就是把组合问题当作排列）



Leetcode 机器人走格子

确定状态

加法原理：无遗漏，无重复

***有几个变量，开几维数组***







**Lintcode 可行性问题 青蛙跳石块**

**1.确定状态**：最后一步：如果青蛙能跳到最后一块石头n-1.

我们考虑它跳的最后一步

这一步是从石头i调过来，且i<n-1

这需要两个条件同时满足：1）青蛙可以跳到石头i

​											2）最后一步不超过跳跃的最大距离n-1-i<=ai

**2.子问题**

我们需要知道青蛙能不能跳到石头i（i<n-1)

**3.转移方程**

设f[j]表示青蛙能不能跳到石头j![截屏2021-03-25 20.43.42](/Users/yyx/Library/Application Support/typora-user-images/截屏2021-03-25 20.43.42.png)

枚举，只要有一个存在，就可以

**4.初始条件和边界情况**

**5.计算顺序**

也是从小到大

时间复杂度O（N2），空间复杂度（数组大小）：O（N）